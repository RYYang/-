1. 删除链表中的节点（237）
```js
var deleteNode = function(node) {
   node.val = node.next.val;
  node.next = node.next.next;
};
```
2. 二叉树最大深度（104）
```js
var maxDepth = function(root) {
    if(root === null) return 0
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
};
```
3. Nim游戏(292)
```js
var canWinNim = function(n) {
    if(n%4===0) return false
    return true
};
```
4. 反转字符串中的单词 III(557)
```js
var reverseWords = function(s) {
    return s.split(' ').map(x=>x.split('').reverse().join('')).join(' ')
};
```
5. 反转字符串(344)
```js
var reverseString = function(s) {
    let len = s.length
    let temp
    for(let i=0;i<len/2;i++){
        temp = s[len-i-1]
        s[len-i-1]=s[i]
        s[i]=temp
    }
};
```
6. 反转链表(206)
注：用了n的额外空间
其它：1原地修改双指针加临时变量，2递归
```js
// 原地反转
temp = p.next
p.next = pre
pre = p
p = temp
// 递归
HEAD = reverseList(head->next);
head->next->next = head;
head->next = NULL;
return HEAD;
```
```js
var reverseList = function(head) {
    let p = head
    let arr = []
    if(head === null) return head
    while(p !== null){
        arr.push(p.val)
        p=p.next
    }
    arr.reverse()
    let res = new ListNode(arr[0])
    let p2 = res
    for(let i=1;i<arr.length;i++){
      p2.next = new ListNode(arr[i]) 
        p2 = p2.next
    }
    p2.next = null
    return res
};
```
7. 只出现一次的数字(136)
注：用了异或
```js
var singleNumber = function(nums) {
    let res = 0
    nums.forEach(x=>{
        res = res ^ x
    })
    return res
};
```
8. 二叉搜索树的最近公共祖先(235)
```js
var lowestCommonAncestor = function(root, p, q) {
          if(p===null||q===null||root===null){
            return null;
        }
    if(root.val>=p.val&&root.val<=q.val) return root
    if(root.val>p.val&&root.val>q.val) {
        return lowestCommonAncestor(root.left,p,q)
    }
    if(root.val<p.val&&root.val<q.val) {
        return lowestCommonAncestor(root.right,p,q)
    }
    return root
};
```
9. 求众数(169)
```js
var majorityElement = function(nums) {
    nums.sort((a,b)=>a-b)
    return nums[Math.floor(nums.length/2)]
};
```
10. 合并两个有序链表
注：也可以用递归，剑指offer有
```js
var mergeTwoLists = function(l1, l2) {
    if (l1 === null) return l2
    if (l2 === null) return l1
    l3 = new ListNode(4)
    p3 = l3
    p1 = l1
    p2 = l2
    while(p1 !== null && p2 !==null){
        if(p1.val <= p2.val){
            p3.next = p1
            p3 = p3.next
            p1 = p1.next
        } else {
            p3.next = p2
            p3 = p3.next
            p2 = p2.next
        }
    }
    if(p1 === null) {
        p3.next = p2
    } else {
        p3.next = p1
    }
  return l3.next
};
```
11. 回文数(9)
```js
var isPalindrome = function(x) {
    if(x.toString() === x.toString().split('').reverse().join('')){
        return true
    }else{
        return false
    }
};
```
12. 122. 买卖股票的最佳时机 II
```js
var maxProfit = function(prices) {
    if(prices.length===0) return 0
    let res = 0
    let min = prices[0]
    for(let i=1;i<prices.length;i++){
        if(prices[i]<prices[i-1]){
            res = res + prices[i-1]-min
            min = prices[i]
        }
    }
    return res + prices[prices.length-1]-min
};
```
13. 121. 买卖股票的最佳时机
```js
var maxProfit = function(prices) {
    if(prices.length === 0) return 0
  let res = 0
  let min = prices[0]
  for(let i=1;i<prices.length;i++){
      if(prices[i]>min){
          res = Math.max(prices[i]-min,res)
      } else {
          min = prices[i]
      }
  }
    return res
};
```
14. 217. 存在重复元素
```js
var containsDuplicate = function(nums) {
    if((new Set(nums)).size === nums.length){
        return false
    } else {
        return true
    }
};
```
15. 155. 最小栈
```js
/**
 * initialize your data structure here.
 */
var MinStack = function() {
    this.data = []; 
};

/** 
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
    this.data.push(x)
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.data.pop()
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.data[this.data.length-1]
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
   return Math.min(...this.data)
};

/** 
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
 ```
 16. 160. 相交链表
 注意：AB长度相加消除长度差异
 ```js
var getIntersectionNode = function(headA, headB) {
    while(headB===null || headA===null) return null
    let pA=headA,pB=headB
    while(pA !== pB){
        if(pA===null){
            pA = headB
        } else {
            pA = pA.next
        }
        if(pB===null){
            pB = headA
        } else {
            pB = pB.next
        }
    }
    return pB
};
 ```
 17. 53. 最大子序和
 注：滑动窗口
 ```js
var maxSubArray = function(nums) {
    let res = nums[0]
    let sum = 0
    for(const num of nums){
        if(sum>0){
            sum += num
        } else {
            sum = num
        }
        res = Math.max(res,sum)
    }
    return res
};
 ```
 18. 70. 爬楼梯
 注：斐波拉契
 ```js
var climbStairs = function(n) {
    if(n===1) return 1
    if(n===2) return 2
    let num1 = 1;
    let num2 = 2;
    for(let i=0;i<n-2;i++){
        let temp = num2
        num2 = num2 + num1
        num1 = temp
    }
    return num2
};
 ```
19. 231. 2的幂
```js
var isPowerOfTwo = function(n) {
    if(+(n.toString(2).split('').reverse().join('')) === 1){return true}
    return false
};
```
20. 26. 删除排序数组中的重复项
```js
var removeDuplicates = function(nums) {
    let cur = nums[0]
    for(let i = 1;i<nums.length;){
        if(nums[i] === cur){
            nums.splice(i,1)
        } else {
            cur = nums[i]
            i++
        }
    }
};
```
21. 88. 合并两个有序数组
```js
var merge = function(nums1, m, nums2, n) {
    nums1.splice(m,n,...nums2)
    nums1.sort((a,b)=>(a-b))
};
```
22. 141. 环形链表
```js
var hasCycle = function(head) {
     if(head === null || head.next === null) return false
    let slow = head
    let fast = head.next
    while(slow !== fast){
        if(fast === null || fast.next === null) return false
        fast = fast.next.next
        slow = slow.next
    }
    return true
};
```
23. 20. 有效括号
注：用栈
```js
var isValid = function (s) {
    const dict = {
        '(':')',
        '[':']',
        '{':'}',
    }
    let stack = []
    for (let i = 0; i < s.length; i++) {
        if(s[i]==='('||s[i]==='['||s[i]==='{'){
            stack.push(s[i])
        } else if(dict[stack[stack.length-1]] === s[i]){
            stack.pop()
        } else {
            return false
        }
    }
    if(stack.length>0) return false
    return true
};
```
24. 14. 最长公共前缀
```js
var longestCommonPrefix = function(strs) {
    if (strs.length === 0) return ''
    let pre = ''
    let str = strs[0]
    for(let j=0;j<str.length;j++){
        let s = str[j]
        for(let i=1;i<strs.length;i++){
            if(strs[i][j]!==s) {
                return pre
            }
        }
        pre = pre+s
    }
    return pre
};
```
25. 7. 整数反转
```js
var reverse = function(x) {
    let num
    if(x>0){
         num = parseInt((''+x).split('').reverse().join(''))  
    } else {
           num = -((-x).toString().split('').reverse().join(''))
    }
    if(num>(2**31-1)||num<-(2**31)){
        return 0
    } else {
        return num
    }
};
```
26. 59. 螺旋矩阵 II
注意： let arr = new Array(3).fill([]),每行都是引用一个地址
```js
var generateMatrix = function (n) {
    let l = 0, r = n - 1, t = 0, b = n - 1;
    let mat = [...Array(n)].map(x=>[])
    let num = 1, tar = n * n;
    while (num <= tar) {
        for (let i = l; i <= r; i++) {
            mat[t][i] = num++; // left to right.
        }
        t++;
        for (let i = t; i <= b; i++) {
            mat[i][r] = num++; // top to bottom.
        }
        r--;
        for (let i = r; i >= l; i--) {
            mat[b][i] = num++; // right to left.
        } 
        b--;
        for (let i = b; i >= t; i--) {
            mat[i][l] = num++; // bottom to top.
        }
        l++;
    }
    return mat;
};
```
27. 78. 子集
```js
var subsets = function(nums) {
    if(nums.length===0) return [[]]
    let sub = subsets(nums.slice(1))
    let res = []
    let a = nums[0]
    for(let i=0;i<sub.length;i++){
        res.push([a,...sub[i]])
    }
    return [...res,...sub]
};
```
28. 46. 全排列
```js
var permute = function(nums) {
    if(nums.length === 1) return [[nums[0]]]
    let res = []
    let sub = permute(nums.slice(1))
    for(let i=0;i<sub.length;i++){
        for(let j=0;j<nums.length;j++){
            let temp = [...sub[i]]
            temp.splice(j,0,nums[0])
            res.push(temp)
        }
    }
    console.log(res.length)
    return res
};
```